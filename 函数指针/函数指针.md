# 函数指针

**函数指针是指向函数的指针**，**用来存放函数的地址**。

## 获取函数的地址

函数也是有地址的，函数的地址通过`&函数名`的方式进行获取：

> ![image-20230126123113325](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126123113325.png)

也可以通过`函数名`直接获取：

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126153116023.png" alt="image-20230126153116023" style="zoom:50%;" />

这两种方式得到的地址的意义相同（数组就是不相同的）。**即`&函数名`和`函数名`都能得到函数的地址**。

## 函数指针的定义

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126153518786.png" alt="image-20230126153518786" style="zoom:50%;" />

如果是上面的这种写法，pa会与(int, int)先结合，这样前面的int*就变成了一个返回值类型，pa就成了函数名，(int, int)则是形参列表，由此int\* pa(int, int)就变成了函数定义，在函数里面定义函数，这样显然是不允许的。

于是上面这种定义方式肯定不是我们想要的。

**实际上函数指针的正确定义如下**：

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126153814109.png" alt="image-20230126153814109" style="zoom:50%;" />

- 此时pa先在()中与*结合就成为了指针，

- 后面的(int, int)声明该指针所指向的函数的形式参数【这里面的(int, int)也可以写成(int x, int y)，当然写不写都是可以的，编译器只要求我们把数据类型交代清楚即可，】

- (*pa)前面的int就用来说明该指针所指向的函数的返回值类型

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126154158153.png" alt="image-20230126154158153" style="zoom:50%;" />

**所以函数指针的定义是**：`指针所指向函数的返回值类型 (*函数指针名)(指针所指向函数的形参列表)`

## 通过函数指针调用函数

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126154537982.png" alt="image-20230126154537982" style="zoom:50%;" />

因为pa存的是函数的地址，那么*pa就可以调用这个函数，并且在(\*pa)后跟上传入函数的参数列表（如上图中红框部分所示）。

## 应用举例1（对上述知识的应用）

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126154908772.png" alt="image-20230126154908772" style="zoom:50%;" />

上面的案例中就是采用了我们上面所讲的函数指针的知识，除此之外我们还可以看到当我们要打印字符串时【printf("%s\n", str)】，我们要用到的是%s，并且其对应的str，这个str是字符串的地址（也即字符串首字符的地址），当我们把一个字符串"hello bit"赋值给str时，就是相当于把这个字符串的地址赋到str中。这部分内容可以参考：[指针（包含指针数组）](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\指针（包含指针数组）.md)中的“指针指向字符串”一小节。

## 应用举例2（难度较大）

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230127133703643.png" alt="image-20230127133703643" style="zoom:50%;" />

> **解**：
>
> ![image-20230127134449317](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230127134449317.png)

- 把0从int类型强制转换为void (*)()函数指针类型，此时的0相当于变成了一个函数的地址

- *解引用找到了这个地址为0，函数参数为无参，返回值类型是void的函数，并传入无参进行调用

[该案例见讲解见视频0：00~10：00处](https://www.bilibili.com/video/BV1oi4y1g7CF/?p=37&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)，另外该案例来自书籍《C陷阱和缺陷》