# 函数指针

**函数指针是指向函数的指针**，**用来存放函数的地址**。

## 获取函数的地址

函数也是有地址的，函数的地址通过`&函数名`的方式进行获取：

> ![image-20230126123113325](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126123113325.png)

也可以通过`函数名`直接获取：

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126153116023.png" alt="image-20230126153116023" style="zoom:50%;" />

这两种方式得到的地址的意义相同（数组就是不相同的）。**即`&函数名`和`函数名`都能得到函数的地址**。

## 函数指针的定义

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126153518786.png" alt="image-20230126153518786" style="zoom:50%;" />

如果是上面的这种写法，pa会与(int, int)先结合，这样前面的int*就变成了一个返回值类型，pa就成了函数名，(int, int)则是形参列表，由此int\* pa(int, int)就变成了函数定义，在函数里面定义函数，这样显然是不允许的。

于是上面这种定义方式肯定不是我们想要的。

**实际上函数指针的正确定义如下**：

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126153814109.png" alt="image-20230126153814109" style="zoom:50%;" />

- 此时pa先在()中与*结合就成为了指针，

- 后面的(int, int)声明该指针所指向的函数的形式参数【这里面的(int, int)也可以写成(int x, int y)，当然写不写都是可以的，编译器只要求我们把数据类型交代清楚即可，】

- (*pa)前面的int就用来说明该指针所指向的函数的返回值类型

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126154158153.png" alt="image-20230126154158153" style="zoom:50%;" />

**所以函数指针的定义是**：`指针所指向函数的返回值类型 (*函数指针名)(指针所指向函数的形参列表)`

## 通过函数指针调用函数

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126154537982.png" alt="image-20230126154537982" style="zoom:50%;" />

因为pa存的是函数的地址，那么*pa就可以调用这个函数，并且在(\*pa)后跟上传入函数的参数列表（如上图中红框部分所示）。

## 应用举例1（对上述知识的应用）

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230126154908772.png" alt="image-20230126154908772" style="zoom:50%;" />

上面的案例中就是采用了我们上面所讲的函数指针的知识，除此之外我们还可以看到当我们要打印字符串时【printf("%s\n", str)】，我们要用到的是%s，并且其对应的str，这个str是字符串的地址（也即字符串首字符的地址），当我们把一个字符串"hello bit"赋值给str时，就是相当于把这个字符串的地址赋到str中。这部分内容可以参考：[指针（包含指针数组）](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\指针（包含指针数组）.md)中的“指针指向字符串”一小节。

## 应用举例2【(*(void (\*)())0)()】

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230127133703643.png" alt="image-20230127133703643" style="zoom:50%;" />

> **解**：
>
> ![image-20230127134449317](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230127134449317.png)

- 把0从int类型强制转换为void (*)()函数指针类型，此时的0相当于变成了一个函数的地址

- *解引用找到了这个地址为0，函数参数为无参，返回值类型是void的函数，并传入无参进行调用

[该案例见讲解见视频0：00~10：00处](https://www.bilibili.com/video/BV1oi4y1g7CF/?p=37&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)，另外该案例来自书籍《C陷阱和缺陷》

## 应用举例3【void (*signal(int, void(\*)(int)))(int)】

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128113053031.png" alt="image-20230128113053031" style="zoom:50%;" />

- signal是函数名

- sginal后面的( int, void(*)(int) )用来说明函数的形参，是一个形参列表。void(\*)(int)是函数指针类型，指向函数形参位int，返回值为void的函数。

- 此时signal既然是函数名，( int, void(*)(int) )又是该函数的形参列表（我们知道一个函数的声明，去掉函数名和形参列表后剩下的就是函数的返回值类型

    所以本例中我们去掉signal( int, void(*)(int) )，剩下的就是void(\*)(int)就是signal函数的返回值类型，是函数指针类型，该指针类型指向函数形参位int，返回值为void的函数。

所以该案例的代码是在声明一个函数。

有同学可能会想，那么该例子的代码能不能写成这样：

> <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128114022396.png" alt="image-20230128114022396" style="zoom:50%;" />

这种写法是不对的！我们思考的使用可以通过这种便捷的方式记忆，但是写的时候，还是需要按照案例代码所示的那样进行书写。

那难道每次定义这样的函数都要这么繁琐吗？有没有可以简化的写法呢？答案是有的！——通过typedef

### typedef简化函数指针类型

对于上面的应用举例3的代码，我们可以看到signal函数的形参之一和返回值类型都有void(\*)(int)，我们可以通过typedef对void(*)(int)这种类型起一个新的名字：

> <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128114516032.png" alt="image-20230128114516032" style="zoom:50%;" />

这种思路是可以的，把void(\*)(int)类型起一个新的类型名教pfun_t。

但是写法不能如上图所示的这样，而是需要写成这样：

> <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128114655365.png" alt="image-20230128114655365" style="zoom:50%;" />

把新的类型名方在*旁边，这样才是函数指针类型应用typedef的正确方法！

此时我们就讲typedef用来简化应用举例3中的对函数声明的代码了，如下：

> <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128114855126.png" alt="image-20230128114855126" style="zoom:50%;" />

并且此时的函数声明与使用typedef前的函数声明效果一致。

### 总结

> ![image-20230128115609480](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128115609480.png)



综上我们可以发现(在没有使用typedef的前提下)：

- 如果函数指针类型用作函数的返回值类型，则函数的函数名和形参列表需要写在*的旁边，如下

    > <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128115137527.png" alt="image-20230128115137527" style="zoom:50%;" />

- 如果函数指针类型用作变量定义，则变量名需写在*旁边，如下：

    > <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128115300358.png" alt="image-20230128115300358" style="zoom:50%;" />

- 如果函数指针类型用作强制类型转换声明，则需要强制转换的值**不写**在*旁边，而是采用下示的方式：

    > <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230128115505744.png" alt="image-20230128115505744" style="zoom:50%;" />

## 函数指针调用函数的补充

> ​	<img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230129164954824.png" alt="image-20230129164954824" style="zoom:50%;" />

以上的代码不管有多少颗解引用的*，运行结果都是一样的，如下：

> <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230129165309575.png" alt="image-20230129165309575" style="zoom:50%;" />

说明：**函数指针的解引用实际上只是一个摆设**。无论多少次解引用，其运行结果都是一样的，所以说明解引用对于函数指针而言是没有用的。、

又或者连一个*都不给，直接写函数指针，也是可以的，如下：

> <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230129170004561.png" alt="image-20230129170004561" style="zoom:50%;" />

程序运行结果如下：

> <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230129170018343.png" alt="image-20230129170018343" style="zoom:50%;" />

又再一次说明了函数的解引用*只是一个摆设。

- (*pa)(2, 3)的方式调用函数是不难理解的，因为pa我们知道是函数指针，要调用这个函数肯定是需要解引用\*的

- 而(pa)(2, 3)【pa外面的括号可以去掉】也不难理解，因为我们可以看到上上个图中第164行代码，是把Add函数名传给pa，那么pa就相当于Add；

    我们调用Add函数是这样的：Add(2, 3)，那么pa(2, 3)或者(pa)(2, 3)也就是同样可行的。

    如下图所示：

    > <img src="D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230129170614987.png" alt="image-20230129170614987" style="zoom:50%;" />

所以综上就是：**对于函数指针而言，解引用的*只是个摆设，并没有实际功能**。但它可以增加代码的可读性。

但如果是下面这种方式：

> ![image-20230129170803077](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230129170803077.png)

那就不行了，此时因为pa后面的()优先级较高，所以pa先与(2, 3)结合，那么此时pa(2, 3)就是一次函数调用，调用的结果就是5，然后得到的5再来*解引用，相当于对5进行解引用

此时编译代码就会报错，如下：

> ![image-20230129170938727](D:\大学\C语言程序设计\C_Learning\C_LearningRecord\函数指针\image-20230129170938727.png)
>
> 报错：非法的间接寻址

所以如果我们要增加*来提升代码的可读性，一定要用()将\*和函数指针给括起来才行！