# 数组指针

> ![image-20230116163435659](E:\Typora\Image\image-20230116163435659.png)
>
> ![image-20230116164656412](E:\Typora\Image\image-20230116164656412.png)
>
> **数组指针是指向数组的指针，其可以存放数组的地址。**

## 数组的地址

> ​	<img src="E:\Typora\Image\image-20230116164903843.png" alt="image-20230116164903843" style="zoom:50%;" />

如上图注释所示，&arr（即对数组名进行取地址）取得的地址才是数组的地址。

现在如果要将数组的地址存放起来，**需要一个指针变量**，比如

> ​	<img src="E:\Typora\Image\image-20230116165111071.png" alt="image-20230116165111071" style="zoom:50%;" />
>
> 这里我们用一个整型指针来存放数组的地址。

这是不允许的，因为整型的指针不能存放一个数组的地址。

再比如下面这种方式

> ​	<img src="E:\Typora\Image\image-20230116165220042.png" alt="image-20230116165220042" style="zoom:50%;" />
>
> 此时的p并不表明是个指针，而是一个数组，即p表示的是一个指针数组。
>
> 这里的p之所以是个数组而不是一个指针，是因为p后面的[]的结合优先级比*高，所以p先和[]结合，它就表示的是一个数组，因此就不是一个指针了。

这种方式也是不允许的，因为此时的p变成了一个数组，而我们要的是一个指针变量......

**那么我们到底要如何声明一个数组指针呢？——在上图中`int* p[10] = &arr;`中p先和[]结合时，p就成了数组；那如果p先和*结合，p不就成了指针吗？——答案是肯定的，就是这样的！**

于是我们这样做：

> ​	<img src="E:\Typora\Image\image-20230116170232537.png" alt="image-20230116170232537" style="zoom:50%;" />
>
> 用括号将p与*二者括起来，这时p就可以与\*优先结合了，于是p就成了一个指针，并且在`int(*p)[10] = &arr;`中如果我们去掉(\*p)，就剩下int[10]，这是一个数组——所以这里就说明了p是一个指针，并且其指向一个数组，并且这个数组有10个元素，每个元素是int类型

**所以此时的p就是一个数组指针，它用来存放数组的地址。**

> <img src="E:\Typora\Image\image-20230116170736923.png" alt="image-20230116170736923" style="zoom:67%;" />

## 小辨析

> ​	<img src="E:\Typora\Image\image-20230116170852360.png" alt="image-20230116170852360" style="zoom:50%;" />

这个案例中p1是一个指针数组，而p2是一个指向10个元素均为int类型的数组指针

## 题目：补充完整数组指针的定义

此部分内容于视频[约10:00~20:00处](https://www.bilibili.com/video/BV1oi4y1g7CF/?p=35&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

> ​	<img src="E:\Typora\Image\image-20230117152342050.png" alt="image-20230117152342050" style="zoom:50%;" />

对于上述案例，请读者补充完整数组指针pa的定义：

> 1. 首先必须保证pa是个指针，所以pa定义时需要在其前面加上一个\*号，并且为了防止后续加上[]时与[]结合，我们还需要加一个括号()，所以最终是这样的(*pa)
> 2. 由于所指向的数组有5个元素，所以(*pa)后面需要跟一个[5]，即(\*pa)[5]。这个[5]表面pa能指向的数组是5个元素的数组
> 3. 由于pa所指向的数组的元素是char\*，所以(*pa)[5]的前面要加一个char\*，此时就变成了char\* (\*pa)[5]。这里char\*表示pa所指向的数组的元素类型是char\*

以上步骤的示意图如下

> ​	<img src="E:\Typora\Image\image-20230117153221299.png" alt="image-20230117153221299" style="zoom:50%;" />

如果上述的步骤读者能够明确，可以再尝试一道：

> ​	<img src="E:\Typora\Image\image-20230117153303828.png" alt="image-20230117153303828" style="zoom:50%;" />

其正确答案如下

> ​	<img src="E:\Typora\Image\image-20230117153341216.png" alt="image-20230117153341216" style="zoom:50%;" />

## 拓展：&数组名与数组名

> ​	<img src="E:\Typora\Image\image-20230118091246072.png" alt="image-20230118091246072" style="zoom:50%;" />
>
> ​	<img src="E:\Typora\Image\image-20230118091314609.png" alt="image-20230118091314609" style="zoom:50%;" />
>
> ​	<img src="E:\Typora\Image\image-20230118091410769.png" alt="image-20230118091410769" style="zoom:50%;" />
>
> ​	<img src="E:\Typora\Image\image-20230118091429316.png" alt="image-20230118091429316" style="zoom:50%;" />
>
> ​	<img src="E:\Typora\Image\image-20230118091446749.png" alt="image-20230118091446749" style="zoom:50%;" />
>
> ![image-20230118091509615](E:\Typora\Image\image-20230118091509615.png)

## 数组指针的应用

### 应用1

> <img src="E:\Typora\Image\image-20230118092036354.png" alt="image-20230118092036354" style="zoom:50%;" />

上述案例中可能存在疑惑的地方是使用pa时的解引用*：因为pa <=> &arr，所以对pa的解引用就等于数组名arr，即\*pa <=> arr，所以\*pa[i]就相当于arr[i]，可以访问数组中的每个元素。

### 区分pa与*pa

另外值得注意的是由于&arr和arr的值是一样的，都表示同一个地址，因而pa和*pa的值也是一样的，如下

> ​	<img src="E:\Typora\Image\image-20230118092521333.png" alt="image-20230118092521333" style="zoom:50%;" />

但是pa表示的是数组的地址，*pa表示的是arr，是首元素的地址，因而它们++之后是不一样的，如下

> ​	<img src="E:\Typora\Image\image-20230118092822565.png" alt="image-20230118092822565" style="zoom:50%;" />

这一点与"拓展：&数组名与数组名"所描述的现象一致。

**总结一句就是说：pa表示的数组地址，*pa表示的是首元素地址；并且\*pa表示数组名。**可以结合下标，即通过(*pa)[i]的方式来访问数组的每个元素。

### 应用2

> ​	<img src="E:\Typora\Image\image-20230118102706504.png" alt="image-20230118102706504" style="zoom:50%;" />

由前面的知识我们知道*pa就相当于arr，而arr又表示的是首元素的地址，那么\*pa+i就是数组arr的第i个元素的地址，再解引用\*(\*pa+i)就能得到数组中的元素了。以上代码的运行结果如下：

> ​	<img src="E:\Typora\Image\image-20230118102850995.png" alt="image-20230118102850995" style="zoom:50%;" />



我们会发现无论是应用1还是应用2，在应用数组指针时都会感觉到别扭......我们甚至不妨可以通过下面这种方式来访问数组元素

> ​	<img src="E:\Typora\Image\image-20230118110741672.png" alt="image-20230118110741672" style="zoom:50%;" />

这种方式还来得更加简单明确......实际上数组指针的常用方法并非应用1和应用2所示，其一般用于二维以上的数组

### 应用3（打印一个二维数组)

#### 打印函数的参数位数组形式

> ![image-20230119160426479](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119160426479.png)

#### 数组名就是首元素地址

> ![image-20230119162431986](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119162431986.png)

- 上图代码中，arr是二维数组的数组名，而我们又知道数组名除了两种特殊的形式（&数组名，sizeof(数组名)）以外，其它的用法都表示的是首元素地址。

- 对于二维数组而言，首元素的地址并非第一行中的1，而是第一行整行，即{1, 2, 3, 4, 5}是该二维数组的首元素，也即arr表示的是{1, 2, 3, 4, 5}的地址，是一个数组的地址，也即arr是一个数组指针；

- 那么此时根据前面数组指针的知识，我们容易知道*arr和arr的值是相同的（都是同一个地址值），但\*arr表示的是数组{1, 2, 3, 4, 5}的首元素地址，即1的地址；arr表示的是{1, 2, 3, 4, 5}的地址。

- 而{1, 2, 3, 4, 5}又是一个元素为int类型，总共有5个元素的数组，即int [5]

- 既然arr是一个数组的地址，那么我们可以用一个数组指针来接收，这个数组指针我们应定义为`int (*pa)[5]`，所以可以有`int (*pa)[5] = arr`，此时pa表示的{1, 2, 3, 4, 5}的地址。于是当我们如果采用同样的方式，将数组传递到一个打印函数进行数组打印时，这个打印函数接收这个数组的形参可以写为如下形式

    > ![image-20230119164836408](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119164836408.png)

    此时的内存示意图如下（主要看蓝框所框部分）

    > ![image-20230119164956562](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119164956562.png)

- 而既然pa表示的是一个数组的地址，那么pa+i就是跳过一个数组，在此案例中pa+0就表示该二位数组的第一行数组的地址，pa+i就表示该二位数组第i+1行的地址（此案例i<=2，应注意不要越界）

- 代码如果写到下面的这一步，*(p+i)表示的就是这个二维数组第i+1行数组（一维数组）的首元素的地址，也或者说是这个二维数组第i+1行数组的数组名

    > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119165413670.png" alt="image-20230119165413670" style="zoom:50%;" />

- 由于*(p+i)表示的是一维数组的首元素地址，那么\*(p+i)+j就是在以该一维数组的元素大小为单位，跳过j个元素（此案例中的元素是int类型，所以跳过j\*4个字节的地址）

    > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119170032652.png" alt="image-20230119170032652" style="zoom:50%;" />

- 此时的\*(p+i)+j也或者说表示的是一维数组中下标为j的元素的地址，所以再对其解引用，就能得到元素了，如下

    > ![image-20230119170400654](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119170400654.png)

- 又或者因为*(p+i)表示的是某一行一维数组的数组名，所以我们也可以通过下标(\*(p+i))[j]的形式对这个一维数组的元素进行访问，如下

    > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230119173522725.png" alt="image-20230119173522725" style="zoom:50%;" />

    当然这里我们应注意在*(p+i)外面要加多一个()以提高优先级，防止(p+i)先与[j]结合导致BUG。

    **综上，p和p+i表示的是数组的地址，\*p和*(p+i)表示的是数组名或者说数组的首元素地址，\*(p+i)+j则表示数组中某个元素的地址，\*(\*(p+i)+j)或(\*(p+i))[j]表示数组中的某个元素。**

## 拓展：指针与数组下标

> ![image-20230120181347968](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230120181347968.png)

**根据上图示例中的结论，`*(p+i) <=> p[i]`**，我们来对下面的代码进行等价转换

> ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230120181512804.png" alt="image-20230120181512804" style="zoom:50%;" />

如图中红色箭头所示即为转化步骤

- **对于*(p+i)，其等价于p[i]（本质）**。该结论**应该**只有在p是数组名（即数组的首元素地址）的情况下，才能在下标访问下正确对应，否则可能存在下标访问方式可用，但与数组实际元素不对应的情况，如下

    > ​	<img src="D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230120212520694.png" alt="image-20230120212520694" style="zoom:50%;" />
    >
    > 虽然不对应，但还是可以一眼看出规律的，如上

- 而*(p[i] + j)，其等价于p\[i][j]

- 又或者*(\*(p + i) + j)，可以等价于\*(p+i)[j]

> ![image-20230120182231846](D:\大学\单片机学习\MCU Learning Resource\STM32\STM32_Projects\3-1 GPIO\Note\image-20230120182231846.png)
>
> 要注意我们上面的案例中是将arr传给*p，而不是&arr。
>
> 所以`arr <=> p`，才有上述的操作合理性。

