# 数据的存储

## 类型的意义

1. 使用这个类型开辟内存空间的大小（大小决定了使用范围）
2. 如何看待内存空间的视角

> ![image-20221207153223143](E:\Typora\Image\image-20221207153223143.png)
>
> 类型不同，视角不同，则相同的数值在内存中实际存储的内容、方式则不同。



## 整形家族

> ​	<img src="E:\Typora\Image\image-20221207153444318.png" alt="image-20221207153444318" style="zoom:50%;" />
>
> 注意
>
> 1. `char`也是整形！
> 2. 定义`short`和`long`时，其后的`int`可以省略也可以加上



## 浮点型(float)家族

> ​	<img src="E:\Typora\Image\image-20221207154334535.png" alt="image-20221207154334535" style="zoom:50%;" />



## 构造类型

> ​	<img src="E:\Typora\Image\image-20221207154516811.png" alt="image-20221207154516811" style="zoom:50%;" />

### 注意

1. 数组属于自定义/构造类型，原因是数组定义时，例如`int arr[10]`、`int arr[5]`，此时去掉数组名后剩下的就是数组类型，即

`int [10]`、`int [5]`，这在C语言中算两种不同的数据类型，而这两者又与`char [10]`、`char [5]`不同。

所以数组在改变其元素个数和元素类型时，其数组类型是发生变化的，所以数组也是一种自定义类型/构造类型



## 指针类型和空类型

> ​	<img src="E:\Typora\Image\image-20221209004033471.png" alt="image-20221209004033471" style="zoom:50%;" />

> 空类型用于说明函数形参时，可以使得程序检测函数调用时是否传递了参数，并在传递参数时予以警告（如果这里的形参不写`void`程序运行不会报警告）
>
> ![image-20221209004356411](E:\Typora\Image\image-20221209004356411.png)



# 指针类型的作用/意义

> ![image-20221227233545563](E:\Typora\Image\image-20221227233545563.png)



## 原码、反码和补码

> ![image-20221209004859537](E:\Typora\Image\image-20221209004859537.png)
>
> 整数/整型分为两种，一种是无符号数，另一种是有符号数。两种都依赖原码、反码、补码。
>
> - 有符号数，其原码、反码、补码各不相同。而有符号数又分为正数和负数：
>     - 正数的原码、反码、补码相同。
>     - 负数的原码、反码、补码各不相同。
> - 无符号数，其原码、反码、补码相同
>
> <img src="E:\Typora\Image\image-20221210214416417.png" alt="image-20221210214416417" style="zoom:67%;" />

## 注意

1. 只有整形数据在计算机中的存储依靠原码、反码、补码，浮点数则不是



## 20和-10在计算机中的存储

> **20**
>
> ![image-20221209201929229](E:\Typora\Image\image-20221209201929229.png)
>
> **-10**
>
> ![image-20221209201807855](E:\Typora\Image\image-20221209201807855.png)
>
> 以上例子我们可以知道，**计算机整型存储的是补码。**至于为什么存储是倒着的（暂不知。。。）



## 计算机存储补码的好处

> ![image-20221210214555462](E:\Typora\Image\image-20221210214555462.png)
>
> [见0:40:00 - 0:44:00处讲解](https://www.bilibili.com/video/BV1oi4y1g7CF/?p=30&spm_id_from=333.788.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)

## 大小端

> ![image-20221222235200421](E:\Typora\Image\image-20221222235200421.png)
>
> 这里发现计算机存储补码时有倒序

>  ![image-20221222235245607](E:\Typora\Image\image-20221222235245607.png)
>
> 注意这里数据的单位是**字节**（0x11223344（十六进制）11、22、33、44都表示一个字节）、而不是二进制位数据

> 理解大端小端
>
> ![image-20221222235654628](E:\Typora\Image\image-20221222235654628.png)

> 说明VS编译器是小端存储模式
>
> ![image-20221223000114897](E:\Typora\Image\image-20221223000114897.png)
>
> ----------------------------------------------——————————————————————————————————————————
>
> ![image-20221223000249506](E:\Typora\Image\image-20221223000249506.png)

> 设计一个判断大小端存储模式的程序
>
> ![image-20221225184950699](E:\Typora\Image\image-20221225184950699.png)
>
> 判断用一个整型值1，判断第一个字节的内容是0还是1，如果是0说明是整形高位在地址的低处，是大端存储；如果是1说明整形低位在地址低处，是小端存储；
>
> **程序实现：**通过char*指针指向存放1的变量的第一个字节，看看其值是0还是1
>
> ![image-20221226191738592](E:\Typora\Image\image-20221226191738592.png)
>
> 但是程序会报一个警告，因为直接的&a所得是一个int*的指针，所以最好在&a前加上一个(char\*)进行强制转换
>
> ​	<img src="E:\Typora\Image\image-20221226191852209.png" alt="image-20221226191852209" style="zoom:50%;" />
>
> ​	并且在做这种面试题的时候最好将功能封装成一个函数，不要直接写在main中，这是一个很重要的习惯
>
> ​	<img src="E:\Typora\Image\image-20221226192222218.png" alt="image-20221226192222218" style="zoom:50%;" />
>
> 进一步简化：
>
> ​	<img src="E:\Typora\Image\image-20221226192312260.png" alt="image-20221226192312260" style="zoom:50%;" />
>
> 注意加上必要的注释，让面试官看到
>
> 还可以进一步优化
>
> ​	<img src="E:\Typora\Image\image-20221226192411794.png" alt="image-20221226192411794" style="zoom:50%;" />
>
> 此时\*(char\*)&a返回值返回的是a变量中的第一个字节的值
>
> [此节内容在0：00~20：00处](https://www.bilibili.com/video/BV1oi4y1g7CF/?p=31&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=b8a7d9f6d396acb27e811371a96d6e9a)
