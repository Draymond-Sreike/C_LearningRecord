# Visual Studio调试技巧

- **F9——产生/取消（红色）断点**

  > 与**F5**搭配使用，让程序瞬间执行至断点处（断点前的程序都执行了）

  <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221118190402949.png" alt="image-20221118190402949" style="zoom:50%;" />

  > 注意：上例如果按F5跳至断点处之后还可以继续按F5，这时继续这次循环，待到下一次循环又遇到该断点时会又停下来（如第一次按F5执行至断点时，i=0，再按一次F5之后，执行至断点，i=1）
  >

  - 断点：代码执行到“这个地方”停下来
  - **条件断点**：用于执行至指定循环次数后产生断点，输入一个条件，满足条件时才会停再断点处

![image-20221121164125043](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221121164125043.png)

![image-20221121164140566](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221121164140566.png)

![image-20221121164151340](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221121164151340.png)

![image-20221121164208080](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221121164208080.png)

- **F5——启动调试**

  > 经常用来直接跳到下一个断点处

- **F10——逐过程**

  > 通常用来处理一个过程，一个过程可以是一次函数调用，或者是一条语句

- **F11——逐语句**

    > 每次都执行一条语句，但是这个快捷键可以使我们的执行逻辑**进入函数内部（这是最常用的）**

- **Shift+F11——跳出（迅速执行完当前函数并跳出该函数）**

    > 程序调试至某个函数内部时，需要**马上执行完该函**数以跳出该函数

- **Ctrl+F5——开始执行不调试**

    > 让程序直接运行起来而不调试

- **自动窗口**

    > 观察程序当前执行位置以上的、同级局部中存在的变量
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119165254593.png" alt="image-20221119165254593" style="zoom: 33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119165342821.png" alt="image-20221119165342821" style="zoom:33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119165407791.png" alt="image-20221119165407791" style="zoom: 33%;" />
    >
    > 可以注意到自动窗口中观察的变量信息是自动添加和销毁的，上面代码的for循环执行时，当语句执行到for内部时，自动窗口才会观察到`arr[i]`而循环出到循环外时，`arr[i]`的观察自动销毁

- **局部变量（窗口）**

    > 观察程序当前所在局部{}中以及该局部外层的所有已存在的（程序执行创建完成的）变量（但无法观察该局部{}所包含的内层局部的变量）
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170058459.png" alt="image-20221119170058459" style="zoom:33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170120244.png" alt="image-20221119170120244" style="zoom:33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170140588.png" alt="image-20221119170140588" style="zoom:33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170200508.png" alt="image-20221119170200508" style="zoom:33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170244386.png" alt="image-20221119170244386" style="zoom:33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170545633.png" alt="image-20221119170545633" style="zoom:33%;" />
    >
    > **注意：局部变量窗口无法查看`arr[i]`**
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170556829.png" alt="image-20221119170556829" style="zoom:33%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170609961.png" alt="image-20221119170609961" style="zoom: 25%;" />
    >
    > <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221119170625935.png" alt="image-20221119170625935" style="zoom:33%;" />

- **自动窗口和局部变量（窗口）的缺陷是：无法让程序员手动的设置要观察的变量值**

- **监视窗口**

    > 程序员手动添加要观察的变量，在程序运行调试期间永不销毁，一直观察

- **内存（监视窗口）**

- **反汇编**

- **寄存器**

- **调用堆栈**

**注意：所有的窗口的打开都是在程序运行调试时才能打开，敲代码的程序没办法打开这些窗口**

## 栈区小知识

**本节内容在P29（1:21:00~1:46:34处**）

栈区内存的默认分配方式：先使用高地址处的内存空间，再使用低地址处的内存空间（如下图）

![image-20221123155332356](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123155332356.png)

而且是根据变量定义的先后顺序来分配内存，先定义的变量则其内存空间的地址较高，后定义的变量其内存空间地址较低（如下图）

- 但应注意数组：随着下标的增长，地址是由低到高变化的（同样如下图）

![image-20221123155513005](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123155513005.png)

> 另外还应注意，若有代码如下
>
> ```c
> for(int i = 0; i <= 12; i++){}
> ```
>
> ​	该代码实际上是C++代码，不是严格的C代码，因为C代码不允许在for循环的头部来定义变量，即`int i = 0`应该在for循环的头部外定义，才符合C语法，在VS里之所以不报错是因为编译器将该代码视为C++，没有严格按照C的语法给予报错，此处应予以注意！

所以由上图中的内存分析框图可知，如果数组下标越界访问到`arr[12]`时，实际上访问到了变量`i`（如下图所示）

![image-20221123160258739](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123160258739.png)

- 注意在VS中，该案例中的变量`i`与数组`arr[]`最后一个元素的间隔是2个int单位的内存空间（即8个字节），不同的编译器，i与arr[]数组的最后一个元素的间隔不同，有如下规律：

> ![image-20221123163905501](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123163905501.png)

- VC6.0的内存分配间隔布局（<=10就死循环）：	

> <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123164044593.png" alt="image-20221123164044593" style="zoom:25%;" />

- GCC的内存分配布局（<=11就死循环）：

> <img src="C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123164149992.png" alt="image-20221123164149992" style="zoom:25%;" />





- 如果将for循环中的循环条件i<=12改成i<=11则不会死循环，但此时系统会报错，说我们数组越界访问（如下图）

![image-20221123163616963](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123163616963.png)

![image-20221123163629560](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123163629560.png)

- 之所以i<=12的时候不会报错，是因为陷入了死循环，编译器没有机会来给我们报错

- 上述代码产生死循环的原因是i的地址高于数组的地址，而数组又随着下标的增加，其地址增加，当数组越界到一定程度之后，就会访问到地址位于高处的变量i，然后将i的值修改导致死循环。
- 如果将i的定义放在数组定义之后，也就是说i变量的内存地址比数组的地址低，则数组越界访问时就永远不会访问到i



- 还应注意VS2022的默认栈内存分配原则变化了，不再是先使用高地址的内存，而是先使用低地址的内存！！！

> ![image-20221123162736862](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221123162736862.png)
>
> 所以不会有越界访问数组时访问到循环控制变量i的情况发生，而是只会在数组越界访问后程序报错



### Relase版本会对Debug版本做优化

![image-20221124132744570](C:\Users\win10\AppData\Roaming\Typora\typora-user-images\image-20221124132744570.png)



## 体验代码的优化过程

项目需求：自己实现一个`strcpy()`

初始代码实现如下：

```c
void my_strcpy(char* dest, char* src);	// 函数声明

// 测试
void test()
{
	char str1[] = "#################";
	char str2[] = "bit";

	my_strcpy(str1, str2);	// 自己实现strcpy
	printf("%s\n", str1);
 }


/// <summary>
/// 自己实现的strcpy函数
/// </summary>
/// <param name="dest">
/// 字符串复制的目的地(char*)
/// </param>
/// <param name="src">
/// 待复制的字符串(char*)
/// </param>
void my_strcpy(char* dest, char* src)
{
	while (*src != '\0')	// src中的'\0'前的字符都要进行复制
	{
		*dest = *src;		// 将待复制字符串的字符复制到目的字符串中
		dest++;				// 指针向后移位，以便进行下一个字符的赋值
		src++;				// 同上
	}
	*dest = *src;			// 最后的'\0'也要复制过去
}
```

注意到`my_strcpy()`函数的函数体中实际上是可以把解引用`*`和自增`++`放在同一行的。于是对strcpy()的优化如下：

```c
void my_strcpy(char* dest, char* src)
{
	while (*src != '\0')		// src中的'\0'前的字符都要进行复制
	{
		*dest++ = *src++;		// 优化
	}
	*dest = *src;				// 最后的'\0'也要复制过去
}
```

> 此时代码中的`*dest++ = *src++`执行过程就是：先执行解引用*，然后进行赋值=，然后执行自增++。
>
> 从表面看这行代码还是比较好直接理解的，就是我们所看到的`*`在前面，`++`又是后置的，所以肯定是先执行了解引用`*`，然后执行后置`++`，而后置`++`执行自增又是在整个语句结束后，也就是赋值语句`=`结束之后才`++`。所以整个语句的执行顺序就是先解引用`*`，然后赋值`=`，然后指针自增。
>
> 但实际的执行顺序是这样的，我先查阅了以下运算符优先级表，表格如下：
>
> ![image-20221126105913204](E:\Typora\Image\image-20221126105913204.png)
>
> `*`和`++`运算符的优先级是相同的，所以此时的结合先后顺序要考虑的是结合性(`=`运算符优先级是较低的，肯定是在最后才执行\结合)，由于是这两个运算符是右结合（右到左），即结合顺序是从右到左，所以是++先结合，然后才是*，也就是说实际上
>
> `*dest++ = *src++`是`++`先执行，然后才是`*`执行，但是由于`++`是后置的，所以尽管`++`先结合或者说先执行（以上表述中的“结合”、“执行”不严格区分，认为是一个意思）了，但是它的自增效果**实现**是在整个语句结束之后，也就是最后的`=`赋值结束之后才`++`，所以最终语句的执行顺序还是：先解引用`*`，然后赋值`=`，然后自增。但我们要知道该语句本质的结合\执行顺序是：先后置`++`，后`*`，然后`=`。**只不过`++`的自增效果实现是在最后而已。**

以上是第一步优化，实际上还可以继续优化：

我们注意到此时`my_strcpy()`函数的实现是把字符串内容的拷贝和`'\0'`的拷贝分为了两个部分，其实没有必要。我们将函数进一步优化后如下：

```cpp
void my_strcpy(char* dest, char* src)
{
	while (*dest++ = *src++) {}		// 优化
}
```

> 此时的代码不仅能够继续实现将字符串中的内容进行复制，并且还能将字符串最后的`'\0'`也进行复制，而且在`'\0'`复制之后`while`循环就会停下来，函数执行完毕。
>
> 这是因为在复制完字符串的最后一个字符后，循环条件处的整个`*dest++ = *src++`表达式的值就是最后一个字符（非`'\0'`），此时相当于循环条件仍是真，会进入空循环体执行，空循环体执行完之后再次来到循环条件处（此时的`src`相较于上一次循环已经是`++`了，其解引用`*`后指向的是`'\0'`，于是在完成赋值操作后，整个表达式的值就是`'\0'`，此时循环条件就变为假，循环结束。这里我们注意到`'\0'`是在完成了赋值操作后，循环才结束的。所以上面的代码就很好地将字符串内容的拷贝和`'\0'`的拷贝合成一个部分\语句，并且能够保证`'\0'`也被拷贝）



以上是第二步优化，如果要考虑代码的健壮性，我们可以再继续优化：

我们考虑这样的情况，如果我们在调用这个函数的时候，不小心给`dest`和`src`传了一个空指针：

```c
void test()
{
	char str1[] = "#################";
	char str2[] = "bit";

	my_strcpy(str1, NULL);	// 传了一个NULL指针
	printf("%s\n", str1);
 }
```

此时代码运行结果如下：

> ![image-20221127203059084](E:\Typora\Image\image-20221127203059084.png)
>
> 程序挂掉了！！！因为我们此时在函数中会访问这个`test()`中传过来的空指针`NULL`，这是非法的！

这就说明我们的代码在健壮性方面存在欠缺，原因就是我们的`my_strcpy()`函数中缺乏对形参变量的合法性判断：我们对主调函数传过来的参数，不管三七二十一就直接开始解引用了。

正确的做法是我们应该对这些形参使用前先进行一个判断：

```c
void my_strcpy(char* dest, char* src)
{
	if (dest != NULL && src != NULL)
	{
		while (*dest++ = *src++) {}
	}
}
```

此时就算我们的`test()`函数在调用`my_strcpy()`的时候给这个函数传递了一个`NULL`指针，程序运行效果如下：

> <img src="E:\Typora\Image\image-20221127204102585.png" alt="image-20221127204102585" style="zoom:50%;" />

可以看到，现在程序至少能够规避掉这个错误而不会挂掉（这是很重要的！因为程序如果其他部分的功能正常，但是因为你这个地方的问题而程序挂掉了，那么其他部分的功能也执行不了！所以我们至少至少的！应该要保证程序不会挂掉！)

这个时候程序就健壮了一些，但是我们还要考虑到，程序更改成这样之后，其实我们是不容易去发现这个错误(或者说是`BUG`)的。

为了让我们的程序更健壮，并且容易进行Debug，我们调用一个函数：`assert()`（我们称之为：断言），其使用必须先包含一个头文件：`<assert.h>`

> `assert()`这个函数的功能是：我们在这个函数()内传入一个表达式
>
> 1. 如果这个表达式的执行结果为真，那么该语句就相当于一个空语句（效果上"相当"，不是执行的时间和空间效率上的"相当"）；
> 2. 如果这个表达式的执行结果为假，那么程序就会在这里报错，并且会显示程序出错的位置信息

那么我们利用这个函数，对`my_strcpy()`进行进一步的改进：

```c
void my_strcpy(char* dest, char* src)
{
	assert( dest != NULL );	// 一旦dest为NULL，该函数就会报错
	assert( src != NULL );	// 一旦src为NULL，该函数就会报错
	while ( *dest++ = *src++ ) {}
}
```

此时我们还是在`test()`函数中给`src`传一个`NULL`，程序运行效果如下：

> ![image-20221127205821784](E:\Typora\Image\image-20221127205821784.png)
>
> 可以看到此时DOS窗口很好地将代码出错的文件路径，出错的位置（行数）都显示了出来

这样的做法将有利于我们编写程序时去发现BUG。修改后的整体代码如下：

```c
void my_strcpy(char* dest, char* src);	// 函数声明

// 测试
void test()
{
	char str1[] = "#################";
	char str2[] = "bit";

//	my_strcpy(str1, NULL);	
//  my_strcpy(NULL, str2);
	my_strcpy(str1, str2);	
    
    printf("%s\n", str1);
 }

void my_strcpy(char* dest, char* src)
{
	assert( dest != NULL );	// 一旦dest为NULL，该函数就会报错
	assert( src != NULL );	// 一旦src为NULL，该函数就会报错
	while ( *dest++ = *src++ ) {}		// 优化
}
```

此时当我们把`test()`在调用时传入正常的参数，代码也能够正常运行：

> <img src="E:\Typora\Image\image-20221127210619840.png" alt="image-20221127210619840" style="zoom:50%;" />

程序优化到这一步就差不多了，我们回想一下：我们写`my_strcpy()`这个函数的目的是要自己实现跟库函数中`strcpy()`的一样的功能。功能现在是实现得差不多了，我们来看看我们写的这个`my_strcpy()`与库函数中的`strcpy()`又有什么不同呢？

通过`MSDN`(微软提供提供给广大程序员的开发大全，是一个帮助文档)我们查阅一下`strcpy()`函数的声明：

> ![image-20221128141559047](E:\Typora\Image\image-20221128141559047.png)

再对比我们写的`my_strcpy()`函数的声明：

```c
void my_strcpy(char* dest, char* src);
```

可以发现有两个区别：

### strcpy()与my_strcpy()的区别

> 1. `strcpy()`的返回值是`char*`类型，`strcpy()`返回值是`void`类型
> 2. `strcpy()`的第二个形参(`src`)有`const`修饰，`strcpy()`则没有

`strcpy()`比我们多的这两个地方，有什么作用呢？接下来我们剖析一下：

### 第一个区别

第一个区别：`char *strSource`中`char`前多了一个`const`修饰：

我们这里先补充一个小知识：

#### 关于`const`的小知识：

##### 常量指针`const 变量类型* 指针名(const int* p)`

有如下代码，我们通过指针`p`去修改一个变量`num`的值：

```c
void test02()
{
	int num = 10;
	int* p = &num;	
	*p = 20;				// num会被修改成20
	printf("%d\n", num);	// 输出：20
}
```

此时如果我们对以上代码进行一个修改：在`int* p = &num`前加上一个`const`修饰，代码如下：

```c
void test02()
{
	int num = 10;
	const int* p = &num;	// const放在指针类型变量(int* p)前
	*p = 20;				
}
```

> 此时第5行代码会报错：表达式必须是可修改的左值

这是因为我们在定义指针变量`p`的时候，这个`const`让这个指针`p`变成了一个**常量指针**（理解：一个指向常量的指针，也就是说这个指针所指向的变量是一个常量，其值是不可用修改的；或者说我们解引用`*p`访问到的这个变量变成了一个常量，其值不可以修改）

此时`*p`访问到的是一个常量，常量无法修改，也即无法赋值，所以编译器会报错如上。

快速的理解就是：我们看到了`const int* p = &num`，也就等价于有`const *p`，那么也就是`*p`是常量，不能`*p = 20`赋值修改

所以当我们将**`const`放在指针变量定义`(int* p)`时，指针类型`(int*)`的前面，此时就可以实现我们所定义的这个指针`p`所指向的内容`*p`不可以被赋值修改。**

还应注意：常量指针使得我们对`p`解引用`*p`时无法修改`*p`中的内容，但如果我们通过`num`去修改还是可以的：

```c
void test02()
{
	int num = 10;
	const int* p = &num;
//	*p = 20;				// 编译器报错：表达式必须是可修改的左值
	num = 20;				// num仍然可以修改
	printf("%d\n", num);	// 输出：20
}
```

> 以上代码的理解方式：
>
> 1. 也就是说，常量指针是使得*p变成了一个常量，但`num`本身仍是一个变量。
>
> 2. 或者这样说，在上面的代码中，`num`中的变量值**有两种方式可以去访问**，一种是通过变量名`num`，另一种是通过指针`*p`，那么指针常量是使得`*p`这种访问方式下：无法修改`*p`中的内容(10)，但是并没有禁止变量名的访问方式修改变量值。
>
> 3. 还可以这样说，常量指针只是限制了指针访问的这个方式/这个角度去访问这个变量时，这个变量成了一个常量，注意是在指针访问的这个角度去看这个变量`num`时有这种效果，但实际上`num`这个变量本质上还是一个变量，所以其仍可以通过自身的变量名`num`去修改其中的值

但是当我们把代码修改成如下时：

```c
void test02()
{
	const int num = 10;		// const修饰变量名
	int* p = &num;			// 取消const对指针的修饰
	*p = 20;				// *p可以修改num中的值
//	num = 20;				// 报错：表达式必须是可修改的左值
	printf("%d\n", num);	// 输出：20
}
```

> 我们采用上面提到的3种理解方式中的第2种来说明这个问题：
>
> 当我们在定义变量`num`的时候，如果在`num`前加上`const`就会导致变量名访问变量的这种方式：无法修改`num`中的变量值(10)，但是此时并没有禁止`*p`的访问方式修改变量值。



**综上所述：**

- **变量有两种访问方式：1.变量名访问；2.指针（解引用）访问**
- **定义变量时**，如果在**变量类型**的**前面**加上`const`修饰，就会导致相应的变量访问方式无法修改变量值：
    1. `const`加在变量名前：`const 变量类型 变量名(const int num)`就使得变量名的访问方式`变量名 = 值(num = 20)`无法修改变量值，但不限制指针（解引用）的访问方式`*指针名 = 值(*p = 20)`修改变量值。
    2. `const`加在指针前：`const 变量类型* 指针名(const int* p)`就使得指针（解引用）的访问方式`*指针名 = 值(*p = 20)`无法修改变量值，但不限制变量名的访问方式`变量名 = 值(num = 20)`修改变量值。
- **常量指针：指向常量的指针，指针所指向的内容(*p)不可改**（当然实际上只是`*p`这种方式不可改，变量名的方式仍可以改）
    - 定义语法：`const 变量类型* 指针名(const int* p)`



那么如果我们想使得两种访问方式都不能修改变量值该怎么做呢？不用说，大家肯定都想得到了，我们直接放出代码：

```c
void test02()
{
	const int num = 10;		// const修饰变量名
	const int* p = &num;	// const修饰指针
//	*p = 20;				// 报错：表达式必须是可修改的左值
//	num = 20;				// 报错：表达式必须是可修改的左值
	printf("%d\n", num);
}
```

我们直接在定义这些变量的时候，前面都加上`const`，那么无论哪种访问方式，它们的修改/赋值功能就都会被禁止。

那么以上是常量指针的相关知识。从上述我们知道**常量指针是指针所指向的内容`*p`不可改**，那么我们又有一个问题：既然指针所指向内容不可改，那**指针本身可以改吗？**我们写一个测试代码，如下：

```c
void test02()
{
	int num1 = 10;
	int num2 = 20;

	const int* p = &num1;	// const修饰指针

//	*p = 20;				// 报错：表达式必须是可修改的左值

	p = &num2;				// 可以执行
}
```

可以发现，**常量指针**所指向的内容`*p`是改不了，但是**指针本身可以改**，也就是说，**指针的指向可以改**（上面的案例中`p`本来是指向`num1`的，后来修改指向了`num2`）

那么我们如果想让指针本身不可改（或者说指针的指向不可以改），又该如何操作呢？接下来我们介绍**指针常量**的知识：



##### 指针常量`变量类型* const 指针名(int* const p)`

对于常量指针我们的理解是：指向常量的指针。那么很自然的，**指针常量的理解**就应该是说，**这个指针本身就是个常量，不可以被修改。**

我们观察我们上面写过的代码：

```c
const int* p = &num1;
```

这行代码所定义的变量`p`就被我们称为常量指针，对比其**书写的位置**也是刚刚好：先是常量`const`，再是指针`*`，所以被我们称为常量指针，那么聪明的我们自然会猜测：指针常量的**书写**应该就应该是...**（注意这里所谓的书写位置对于指针常量和常量指针的理解，有助于我们记忆和区分这两种指针）**

```c
int* const p = &num1;
```

这样？......

没错，**指针常量**还真就是这样！其**定义语法**就是：`变量类型* const 指针名(int* const p)`

此时如果我们在程序中定义这样的指针常量：

```c
void test02()
{
	int num1 = 10;
	int num2 = 20;

	int* const p = &num1;	// 定义指针常量

	*p = 20;				// 可以执行
		
//	p = &num2;				// 报错：表达式必须是可修改的左值
}
```

会发现指针`p`（是一个指针常量）本身是无法修改的（也即其指向是无法修改的），但是其指向的内容`*p`可以访问和修改

这就是**指针常量：指针本身（或者说指针的指向）无法修改**



##### 快速区分方法

对比常量指针和指针常量的定义语法，我们如何快速地注意和区分这两者的称谓和功能呢？

常量指针：`const 变量类型* 指针名(const int* p)`

指针常量：`变量类型* const 指针名(int* const p)`

1.首先最容易的就是通过我们上面说到过的书写位置：

- 常量指针的`const`是放在`*`前的，所以我们按照这样的**书写顺序**就可以称之为：常量`const`指针`*`

- 而指针常量的`*`是放在`const`后的，所以我们同样按照书写顺序就可以称之为：指针`*`常量`const`

2.上面区分了二者的叫法，那又如何快速区分二者的功能呢？如下：

- 常量指针是`const 变量类型* 指针名(const int* p)`，省略中间的`int`，简化之后就是 `const *p`，也就是说`*p`就是个常量，不可以修改。也就是我们上面说的：常量指针所指向的内容是常量，不可以修改。

​		但此时`p`本身可以修改，原因就是`const`修饰的是`*p`，而不是`p`。

- 指针常量是`变量类型* const 指针名(int* const p)`，简化之后就是 `const p`，也就是说p是个常量，不可以修改，也同样对应我们上面说的：指针常量本身（或者说指针的指向）不可用修改。

​		但此时`*p`的内容可以修改，原因就是`const`修饰的是`p`，而不是`*p`。



那么由以上的知识我们可以继续思考，如果要使得一个指针p不仅所指向的内容`*p`不可修改，其本身p（其指向）不可修改又该如何做呢？相信大家肯定都想得到，这里我们直接放出代码：

```c
void test02()
{
	int num1 = 10;
	int num2 = 20;

	const int* const p = &num1;	// p即是常量指针，又是指针常量，它同时具有两种这两种指针的特点

//	*p = 20;					// 报错：表达式必须是可修改的左值
		
//	p = &num2;					// 报错：表达式必须是可修改的左值
}
```

可以看到此时无论是我们去修改指针所指向的内容或者修改指针本身都会报错，也就是说两者都改不了！



那么我们回到我们的问题，`strcpy()` 函数的第二个形参`char *strSource`在`char`的前面多了一个`const`修饰有什么用呢？

我们先看我们自己写的`my_strcpy()`函数的代码：

```c
void my_strcpy(char* dest, char* src)
{
	assert( dest != NULL );
	assert( src != NULL );
	while ( *dest++ = *src++ ) {}
}
```

我们写这个函数的目的是将源字符串`src`中的内容赋值到目标字符串`dest`中，实现这个过程的语句是上面的第五行代码

```c
`while ( *dest++ = *src++ ) {}`
```

设想如果我们哪天在复刻这个代码的时候，不小心把`dest`和`src`的位置写反了，写成了这样：

```c
`while ( *src++ = *dest++ ) {}`
```

程序肯定会出问题！

或者说我们在函数中对`src`的内容`*src`不小心进行了修改（`src`是我们要复制的字符串，其内容是我们在调用这个函数的时候不希望会被修改的）

这些都是不允许的，最根本的原因就是我们调用这个函数的初衷是为了复制，并不希望待复制的字符串反过来被莫名其妙地修改。但是项目开发的过程中，犯这样这样的错误在所难免（变量用着用着，不小心就把它改掉了......）

所以为了避免这样的问题发生我们可以在`my_strcpy()`形参`src`的位置利用`const`修饰：

```c
void my_strcpy(char* dest, const char* src)	// const常量指针，src所指向的内容*src不可被修改
{
	assert( dest != NULL );	
	assert( src != NULL );
	while ( *dest++ = *src++ ) {}
}
```

这样让`src`变成一个常量指针之后，在函数中就使得其指向的内容`*src`不会被错误修改，即使程序员不小心写错了，想修改src中的内容，编译器也会及时地报错：表达式必须是可修改的左值。

所以代码到了这里，第一个区别存在的原因我们就清楚了，代码的优化就又进了一步，代码产生BUG的可能性就更小了。

### 第二个区别

接下里我们继续看第二个区别：`strcpy()`的返回值是`char*`类型，`strcpy()`返回值是`void`类型

那么返回的这`char*`类型有什么用呢？我们查阅帮助文档：

> ![image-20221128182555208](E:\Typora\Image\image-20221128182555208.png)

可以获知`strcpy()`的返回值是目标字符串`strDestination`的地址，这样做有什么用呢？

> 用途：
>
> ​	可以用于直接作为`printf`对字符串的输出：`printf("%s\n", my_strcpy(str1, str2))`，这里也体现了链式访问的思想
>
> （函数（的返回值）直接作为另一个函数参数）

要使得我们的`my_strcpy()`函数返回目标字符串`strDestination`的地址，我们将函数更改后如下：

```c
char* my_strcpy(char* dest, const char* src)	// 返回值类型修改为char*
{
	char* tempSave_Addr = dest;					// 保存目标字符串strDestination的起始地址

	assert( dest != NULL );
	assert( src != NULL );
	while ( *dest++ = *src++ ) {}
	
	return tempSave_Addr;						// 返回值目标字符串strDestination的起始地址

}
```

此时我们可以验证刚才提到的第一个用途，直接用于`printf`打印输出复制后的目标字符串`strDestination`：

```c
void test()
{
	char str1[] = "#################";
	char str2[] = "bit";
    
//	my_strcpy(str1, str2);
//	printf( "%s\n", str1);
// 	上面的两行代码合为下面一行：
    printf( "%s\n", my_strcpy(str1, str2));
 }
```

程序运行后输出了被复制后的`str1`，跟我们修改之前的运行效果一致。

这个地方也体现了链式访问（函数的返回值作为另一个函数的参数），程序的这一步修改，其多了一个功能：这个函数可以直接作为其他函数的参数。功能进一步丰富了。

最后我们加上必要的注释之后，整体代码如下：

```c
#include<stdio.h>
#include<stdlib.h>
#include<assert.h>

char* my_strcpy(char* dest, char* src);		// 函数声明

// 测试
void test()
{
	char str1[] = "#################";
	char str2[] = "bit";

	printf("%s\n", my_strcpy(str1, str2));	// 打印被复制后的目标字符串
}


/// <summary>
/// 将src指向的字符串拷贝到dest指向的空间，包括'\0'字符
/// </summary>
/// <param name="dest">
/// 字符串复制的目的地(char*)
/// </param>
/// <param name="src">
/// 要复制的字符串(char*)
/// </param>
char* my_strcpy(char* dest, const char* src)
{
	char* tempSave_Addr = dest;			// 保存目标字符串strDestination的起始地址
	
	// 以下两行代码是断言，用于保证指针的有效性
	assert( dest != NULL );				// 一旦dest为NULL，该函数就会浮窗报错
	assert( src != NULL );				// 一旦src为NULL，该函数就会浮窗报错

	while ( *dest++ = *src++ ) {}		// 将src指向的字符串拷贝到dest指向的空间，包括'\0'字符
	
	return tempSave_Addr;				// 返回值目标字符串strDestination的起始地址
}


int main()
{
	test();

	system("pause");
	return 0;
}
```

程序运行结果：

> <img src="E:\Typora\Image\image-20221128192051473.png" alt="image-20221128192051473" style="zoom:50%;" />

以上就是我们关于自己编写一个类似`strcpy()`函数my_strcpy()的过程，体验代码优化的一个过程。目的在于提高我们的`coding`技巧，减少`BUG`的产生，即使产生`BUG`不可用避免，也要学会如何编写程序使得我们`Debug`的难度降低。

顺便分享比特鹏哥给我们的`coding`技巧建议：

> 1. 尽量使用`assert`
> 2. 尽量使用`const`
> 3. 养成良好的编码风格
> 4. 添加必要的注释
> 5. 避免编码的陷阱（野指针滥用，如上面代码实现过程中的NULL）



## 链接型错误

如果程序有报错如下：

> ![image-20221128191100846](E:\Typora\Image\image-20221128191100846.png)

一般导致这个错误的原因是：

> 1. 符号（比如主程序中要使用这个`add()`函数，但主程序外却没有定义这个函数）没有定义
> 2. 符号定义了，但是在调用时写错了（比如主程序中调用程函数时写的是`Add(a, b)`，但是定义函数名实际上是`add`）
